/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package haarfilterall.features;

import haarfilterall.util.CalculateFeature;
import haarfilterall.util.FeatureNormalization;

/**
 *
 * @author user
 */
public class Features {

    /**
     * Two layer Horizontal Sliding Window
     */
    public float[] FeatureA(int w, int h, int[][] intValues) {
        int imgH = 24;
        int imgW = 24;
        int count = 0;
        int tempFeature = 0;
        int absValue = 0;
        int[] featureValues = new int[43200];
        float[] tempFeatureValues = new float[43200];
        int max = 0;
//        int[][] integralValues = new int[5][5];
        /**
         * Image area is a class to calculate the area of a certain window
         * generated by the i and j values in the following loop and sliding it
         * through each position of the array which will later be replaced by an
         * image to calculate its features
         */
        CalculateFeature calculateFeature = new CalculateFeature();

        for (int i = 1; i <= (imgW / w); i++) {
            for (int j = 1; j <= (imgH / h); j++) {
                for (int x = 2; x <= (imgW - i * w + 1); x++) {
                    for (int y = 2; y <= imgH - j * h + 1; y++) {
                        /**
                         * CalculateArea gives the area of the selected window
                         * with reference to the integral image and drastically
                         * reduces the computation time
                         */
//                        if (x != 1 && y != 1) {

                        tempFeature = calculateFeature.CalculateSubtractionA(i, j, x, y, count, intValues);
                        count++;
                        featureValues[count] = tempFeature;
                        absValue = Math.abs(tempFeature);
                        if (absValue > max) {
                            max = absValue;
//                            System.out.println("maX" + max);
                        }
//                        System.out.println("Feature[" + count + "] = " + tempFeature);
//                        }
                    }
                }
            }
        }
        System.out.println("Count feature A " + count);
        FeatureNormalization featureNormalization = new FeatureNormalization();
        tempFeatureValues = featureNormalization.FeaNormal(featureValues, count, max);
//        for(int norCntr = 0 ; norCntr < 36432 ; norCntr++){
//            System.out.println("Values " + featureValues[norCntr]);
////            featureValues[norCntr] = featureValues[norCntr]/max;
//          float temp = ((float)featureValues[norCntr])/max;
//            System.out.println("Feature[" + norCntr + "] = " + temp);
//        }
        return tempFeatureValues;
    }

    /**
     * Rest of the program follows exactly the same pattern as the above
     * function. Different functions created to reduce the time taken by
     * IF..ELSE statements. Direct calls to the function
     */
    /**
     * Two layer Vertical Sliding Window
     */
    public float[] FeatureB(int w, int h, int[][] intValues) {
        int imgH = 24;
        int imgW = 24;
        int count = 0;
        int tempFeature = 0;
        int[] featureValues = new int[43200];
        float[] tempFeatureValues = new float[43200];
//        int[][] integralValues = new int[5][5];
        int absValue = 0, max = 0;

        CalculateFeature calculateFeature = new CalculateFeature();

        for (int i = 1; i <= (imgH / h); i++) {
            for (int j = 1; j <= (imgW / w); j++) {
                for (int x = 2; x <= (imgH - i * h + 1); x++) {
                    for (int y = 2; y <= imgW - j * w + 1; y++) {
//                        if (x != 1 && y != 1) {
                        tempFeature = calculateFeature.CalculateSubtractionB(j, i, y, x, count, intValues);
                        count++;
                        featureValues[count] = tempFeature;
                        absValue = Math.abs(tempFeature);
                        if (absValue > max) {
                            max = absValue;
//                            System.out.println("maX" + max);
                        }
//                            System.out.println(tempFeature);
//                            System.out.println("Feature[" + count + "] = " + tempFeature );
//                        }
                    }
                }
            }
        }

        System.out.println("Count feature B " + count);
        FeatureNormalization featureNormalization = new FeatureNormalization();
        tempFeatureValues = featureNormalization.FeaNormal(featureValues, count, max);
        return tempFeatureValues;
    }

    /**
     * Three layer Horizontal Sliding Window
     */
    public float[] FeatureC(int w, int h, int[][] intValues) {
        int imgH = 24;
        int imgW = 24;
        int count = 0;
        int tempFeature = 0;
        int[] featureValues = new int[27600];
        float[] tempFeatureValues = new float[43200];
//        int[][] integralValues = new int[5][5];
        int absValue = 0, max = 0;

        CalculateFeature calculateFeature = new CalculateFeature();

        for (int i = 1; i <= (imgW / w); i++) {
            for (int j = 1; j <= (imgH / h); j++) {
                for (int x = 2; x <= (imgW - i * w + 1); x++) {
                    for (int y = 2; y <= imgH - j * h + 1; y++) {
//                        if (x != 1 && y != 1) {
                        tempFeature = calculateFeature.CalculateSubtractionC(i, j, x, y, count, intValues);
                        count++;
                        featureValues[count] = tempFeature;
                        absValue = Math.abs(tempFeature);
                        if (absValue > max) {
                            max = absValue;
//                            System.out.println("maX" + max);
                        }
//                        }
                    }
                }
            }
        }
        System.out.println("Count feature C " + count);
        FeatureNormalization featureNormalization = new FeatureNormalization();
        tempFeatureValues = featureNormalization.FeaNormal(featureValues, count, max);
        return tempFeatureValues;
    }

    /**
     * Four layer Rectangular Sliding Window
     */
    public float[] FeatureE(int w, int h, int[][] intValues) {
        int imgH = 24;
        int imgW = 24;
        int count = 0;
        int tempFeature = 0;
        int[] featureValues = new int[43200];
        float[] tempFeatureValues = new float[43200];
//        int[][] integralValues = new int[5][5];
        int absValue = 0, max = 0;

        CalculateFeature calculateFeature = new CalculateFeature();

        for (int i = 1; i <= (imgW / w); i++) {
            for (int j = 1; j <= (imgH / h); j++) {
                for (int x = 2; x <= (imgW - i * w + 1); x++) {
                    for (int y = 2; y <= imgH - j * h + 1; y++) {

//                        if (x != 1 && y != 1) {
                        tempFeature = calculateFeature.CalculateSubtractionE(i, j, x, y, count, intValues);
                        count++;
                        featureValues[count] = tempFeature;
                        absValue = Math.abs(tempFeature);
                        if (absValue > max) {
                            max = absValue;
//                            System.out.println("maX" + max);
                        }
//                        }
                    }
                }
            }
        }
        System.out.println("Count feature E " + count);
        FeatureNormalization featureNormalization = new FeatureNormalization();
        tempFeatureValues = featureNormalization.FeaNormal(featureValues, count, max);
        return tempFeatureValues;
    }
}
